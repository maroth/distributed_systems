\documentclass[a4paper, 11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{verbatim}
\usepackage{moreverb}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{listings} 
\usepackage{lastpage}
\usepackage[top=3cm, bottom=3cm, left=2cm, right=2cm]{geometry}
\usepackage{color}
\usepackage{xcolor}

%font change
\renewcommand{\familydefault}{\sfdefault}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\newcommand{\nl}{\\[0.1cm]}
\newcommand{\s}{\vspace{0.3cm}}
\newcommand{\smore}{\vspace{0.6cm}}

\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}

\lstset{frame=single}

\lstdefinelanguage{popc}{%
   morekeywords={%
   %od
      od, url, power, @, 100, 80, machine, POPString, search
  },
  sensitive=true,
  morestring=[b]',
}

\addto\captionsenglish{%
  \renewcommand{\listfigurename}{}%
	\renewcommand\refname{}
}



%Header and footer 
\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}

%Header definition
\renewcommand{\headrulewidth}{0.5pt}
\lhead{ViSaG : Virtual Safe GRID}
\rhead{Version 1.1}

%Footer definition
\renewcommand{\footrulewidth}{0.5pt}
\cfoot{\today}
\lfoot{Valentin Cl√©ment}
\rfoot{Page \thepage ~on \pageref{LastPage}}

%remove indent for paragraph
\parindent0ex 

%\setlength{\parskip2ex}








%\pagebreak



\begin{document}

\input{title}
%\newpage \thispagestyle{empty} \mbox{}\newpage



\tableofcontents
\pagebreak
\section{Introduction}
This document introduces the POP-C++ support for CMake to the POP-C++ developer. This is a user manual and nothing is related to the implementation of this support in this document. 
\subsection{CMake introduction}
The following introduction is from the CMake project website\cite{cmake}.\s

CMake is an extensible, open-source system that manages the build process in an operating system and in a compiler-independent manner. Unlike many cross-platform systems, CMake is designed to be used in conjunction with the native build environment. Simple configuration files placed in each source directory (called CMakeLists.txt files) are used to generate standard build files (e.g., makefiles on Unix and projects/workspaces in Windows MSVC) which are used in the usual way. CMake can generate a native build environment that will compile source code, create libraries, generate wrappers and build executables in arbitrary combinations. CMake supports in-place and out-of-place builds, and can therefore support multiple builds from a single source tree. CMake also supports static and dynamic library builds. Another nice feature of CMake is that it generates a cache file that is designed to be used with a graphical editor. For example, when CMake runs, it locates include files, libraries, and executables, and may encounter optional build directives. This information is gathered into the cache, which may be changed by the user prior to the generation of the native build files.

\subsection{POP-C++ support in CMake}
As POP-C++ has a specific build process, the need of new command in cmake was obvious. These commands are separated in two sub-groups: 

\begin{itemize}
\item Compiling (ADD\_POPC\_MAIN, ADD\_POPC\_OBJECT)
\item Object map generation (ADD\_POPC\_OBJMAP)
\end{itemize}

These commands are detailed in  Chapter \ref{chap:instruction}. POP-C++ in CMake is referred as POPCPP.\s

This document is structured as follow: 
\begin{itemize}
\item Chapter \ref{chap:instruction} details the three new commands added in CMake. 
\item Chapter \ref{chap:tips} gives some instructions to the developers about the specificity of this language support.
\item Chapter \ref{chap:install} explains how to install the support.
\item Chapter \ref{chap:example} gives two examples of CMakeLists.txt file with POP-C++.
\end{itemize}


\section{CMake new instruction for POP-C++}
\label{chap:instruction}

\subsection{ADD\_POPC\_MAIN}	
This instruction is used to compile a POP-C++ main. Its signature is as follow:\s
\begin{lstlisting}
ADD_POPC_MAIN(target source1 [source2 ...] [FLAGS flag1 [flag2 ...]]
[DEP dependency1 [dependency2]])
\end{lstlisting}

This command will define a new target executed in the build process. Flags can be overwritten with the FLAGS option. The default flag is "-o". Dependencies to this target can be added with the option DEP. 


\subsection{ADD\_POPC\_OBJECT}
This instruction is used to compile a POP-C++ object. Its signature is as follow:\s
\begin{lstlisting}
ADD_POPC_OBJECT([target] source1 [source2 ...] [FLAGS flag1 [flag2 ...]]
[DEP dependency1 [dependency2]] [NOBROKER|NOPARALLEL] )
\end{lstlisting}\s

This command will define a new target executed in the build process. Flags can be overwritten with the FLAGS option. The default flags are "-object -o". Dependencies to this target can be added with the option DEP. The option NOBROKER will compile the target with the following flags: "-parclass-nobroker -c". The target name will be set automatically with the name of the first source file. For example, if the first source file is named source1.ph, the target will be named nobroker-source1.ph.
The option NOPARALLEL is used to compile non-parallel object. The flags used for this option are "-c". The target will also be named with the first source file. For example, if the first source file is named source1.ph, the target will be named object-source1.ph.


\subsection{ADD\_POPC\_OBJMAP}
This instruction is used to generate the POP-C++ object map. Its signature is as follow:\s
\begin{lstlisting}
ADD_POPC_OBJMAP(obj1 [obj2 ...] [OBJECTMAP name] [NOT_APPEND])
\end{lstlisting}\s

This command will defined a new target executed in the build process to generate an object map. The option OBJECTMAP can be specified to change the name of the generated object map file. The default name is "obj.map". The option NOT\_APPEND will erase any object map file with the same name in the current folder. 

\section{Developer tips}
\label{chap:tips}
\subsection{CMake version}
The POP-C++ support for CMake has been developed with the version 2.8 of CMake. There is no guarantee this will work with an older version. \s

\subsection{Target order}
As CMake process target in a special order, there is no guarantee the compilation process will follow the command flow. To manage the order of the compilation process, please use the dependencies. 

\section{Installation}
\label{chap:install}
To install the POP-C++ support for CMake, cmake must be installed on the operating system. In the distribution, there is a \textbf{cmake} directory. This directory has a \textbf{CMakeLists.txt} file. To install, just run the cmake make command in this directory as follow:\s

\begin{lstlisting}
user@machine:~/popc2.0/cmake$ cmake . 
\end{lstlisting}



\section{Example of CMakeLists.txt files}
\label{chap:example}
\subsection{Simple CMake file}
The following code shows a simple CMake file to compile an application with one parallel object and one main. Line 1 is set to defined the minimum version of CMake to be used. POP-C++ support for CMake use the version 2.8 or later. \\
On line 2, the project name is defined and the option NONE is set to avoid any other programming language. Line 3 enable the programming language POP-C++.\s

The lines 5 and 6 will create two targets for the compilation of the application. The line 7 will create a target to generate the object map file. \s

\begin{lstlisting}
1: CMAKE_MINIMUM_REQUIRED(VERSION 2.8)
2: PROJECT(simple-project NONE)
3: ENABLE_LANGUAGE(POPCPP)
4: 
5: ADD_POPC_OBJECT(integer.obj integer.cc integer.ph)
6: ADD_POPC_MAIN(main main.cc integer.cc integer.ph)
7: ADD_POPC_OBJMAP(integer.obj NOT_APPEND)
\end{lstlisting}


\subsection{Advanced CMake file}
In this example, the order of compilation is important. Using dependencies allows the developer to control the compilation process. In the line 5, the option NOBROKER is used. The created target will be named nobroker-Barrier.ph. This target is a dependency of the "main" compilation. The target nobroker-Barrier.ph will generate Barrier.o and Barrier.stub.o. These files are used in the next command. \s
\begin{lstlisting}
1: CMAKE_MINIMUM_REQUIRED(VERSION 2.8)
2: PROJECT(test-barrier NONE)
3: ENABLE_LANGUAGE(POPCPP)
4:
5: ADD_POPC_OBJECT(Barrier.ph Barrier.cc NOBROKER)
6: ADD_POPC_MAIN(main-barrier Barrier.stub.o worker.ph worker.cc main.cc 
DEP nobroker-Barrier.ph)
7: ADD_POPC_OBJECT(Cworker.obj Barrier.stub.o worker.cc worker.ph 
DEP main-barrier)
8: ADD_POPC_OBJECT(Barrier.obj Barrier.ph Barrier.cc DEP Cworker.obj)
9: ADD_POPC_OBJMAP(Cworker.obj Barrier.obj NOT_APPEND)
\end{lstlisting}\s

For more example of CMakeLists.txt files, please refers to the POP-C++ test suite with CMake support in the distribution (In the following directory: \textit{POPC\_DISTRIB}/test\_cmake/)


%\pagebreak
%\section{Table of figures}
%\listoffigures{}

%
% 
%

\section{References}
\begin{thebibliography}{9}
\bibitem{cmake}
	Kitware Software,
  	\emph{CMake project introduction}, http://www.cmake.org/cmake/project/about.html
	


\end{thebibliography}


%-- APPENDIX

\pagebreak
\appendix
%\input{appendix.tex}




\end{document}
